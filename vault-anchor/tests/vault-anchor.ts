/*import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { VaultAnchor } from "../target/types/vault_anchor";
import { sign } from "crypto";
import { LAMPORTS_PER_SOL } from "@solana/web3.js";

describe("vault-anchor", () => {
  // Configure the client to use the local cluster.
  const provider = anchor.AnchorProvider.env(); 
  anchor.setProvider(provider);

  const program = anchor.workspace.vaultAnchor as Program<VaultAnchor>;
  
  const vaultState = anchor.web3.PublicKey.findProgramAddressSync(
    [Buffer.from("state"), provider.publicKey.toBytes()],
    program.programId
  )[0];

  const vault = anchor.web3.PublicKey.findProgramAddressSync(
    [Buffer.from("vault"), vaultState.toBytes()],
    program.programId
  )[0];

  it("Is initialized!", async () => {
    // Add your test here.
    const tx = await program.methods
    .initialize()
    .accountsPartial({
      user: provider.wallet.publicKey,
      vaultState,
      vault,
      systemProgram: anchor.web3.SystemProgram.programId,
    })
    .rpc();
  
    console.log("\nYour transaction signature", tx);
    console.log("Your vault info", 
      await provider.connection.getAccountInfo(vault)
    );
  });

  it("Deposit 2 SOL", async () => {
    // Add your test here.
    const tx = await program.methods
      .deposit(new anchor.BN(2 * anchor.web3.LAMPORTS_PER_SOL))
      .accountsPartial({
        user: provider.wallet.publicKey,
        vaultState,
        vault,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .rpc();

      console.log("\nYour transaction signature", tx);

      const vaultInfo = await provider.connection.getAccountInfo(vault);

      if (vaultInfo) {
          console.log("Your vault balance", vaultInfo.lamports / LAMPORTS_PER_SOL, "SOL");
      } else {
          console.log("Vault account not found");
      }

  });

  it("Withdraw 1 SOL", async () => {
    // Add your test here.
    const tx = await program.methods
      .withdraw(new anchor.BN(1 * anchor.web3.LAMPORTS_PER_SOL))
      .accountsPartial({
        user: provider.wallet.publicKey,
        vaultState,
        vault,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .rpc();

      console.log("\nYour transaction signature", tx);
      console.log("Your vault balance", 
        (await provider.connection.getAccountInfo(vault)).toString()
      );
  });

  it("Close the vault", async () => {
    // Add your test here.
    const tx = await program.methods
      .close()
      .accountsPartial({
        user: provider.wallet.publicKey,
        vaultState,
        vault,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .rpc();

      console.log("\nYour transaction signature", tx);
      console.log("Your vault balance", 
        await provider.connection.getAccountInfo(vault)
      );
  });

});*/
// Import everything from Anchor
import * as anchor from "@coral-xyz/anchor";

// Import the typed Program interface
import { Program } from "@coral-xyz/anchor";

// This is the IDL type for your program, auto-generated by Anchor when you build
import { VaultAnchor } from "../target/types/vault_anchor";

// LAMPORTS_PER_SOL is used to convert SOL â†” lamports (1 SOL = 1,000,000,000 lamports)
import { LAMPORTS_PER_SOL } from "@solana/web3.js";

// Define the test suite
describe("vault-anchor", () => {
  const provider = anchor.AnchorProvider.env();   // Load the default provider from the Anchor environment (usually your local wallet and devnet/localnet RPC) 
  
  // Set this provider globally for the Anchor framework
  anchor.setProvider(provider);

  // Get a reference to the deployed program using the IDL
  const program = anchor.workspace.vaultAnchor as Program<VaultAnchor>;

  // Derive the vaultState PDA using seeds ["state", user public key]
  const vaultState = anchor.web3.PublicKey.findProgramAddressSync(
    [Buffer.from("state"), provider.publicKey.toBytes()], // User's public key
    program.programId
  )[0];

  // Derive the vault PDA using seeds ["vault", vaultState PDA]
  const vault = anchor.web3.PublicKey.findProgramAddressSync(
    [Buffer.from("vault"), vaultState.toBytes()], // Vault state PDA
    program.programId
  )[0];

  // First test: Initialize the vault
  it("Is initialized!", async () => {
    // Calls the `initialize` instruction in the smart contract
    const tx = await program.methods
      .initialize() // No arguments required
      .accountsPartial({
        user: provider.wallet.publicKey,            // Signer and account owner
        vaultState,                                 // The derived vaultState PDA
        vault,                                      // The derived vault PDA
        systemProgram: anchor.web3.SystemProgram.programId, // Required for creating accounts
      })
      .rpc(); // Send the transaction

    // Log the transaction signature and check that the vault was created
    console.log("\nYour transaction signature", tx);
    console.log("Your vault info", 
      await provider.connection.getAccountInfo(vault)
    );
  });

  // Second test: Deposit 2 SOL
  it("Deposit 2 SOL", async () => {
    // Calls the `deposit` instruction with 2 SOL (in lamports)
    const tx = await program.methods
      .deposit(new anchor.BN(2 * LAMPORTS_PER_SOL)) // Wrap 2 SOL in BN for precision. BN means BigNumber which is used to handle large numbers. 
      .accountsPartial({
        user: provider.wallet.publicKey,            // Signer
        vaultState,                                 // Vault state account
        vault,                                      // Vault SOL-holding account
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .rpc(); // Send transaction

    // Log the signature and print vault's updated SOL balance
    console.log("\nYour transaction signature", tx);

    const vaultInfo = await provider.connection.getAccountInfo(vault);

    if (vaultInfo) {
      // If vault exists, print balance in SOL
      console.log("Your vault balance", vaultInfo.lamports / LAMPORTS_PER_SOL, "SOL");
    } else {
      console.log("Vault account not found");
    }
  });

  // Third test: Withdraw 1 SOL
  it("Withdraw 1 SOL", async () => {
    // Calls the `withdraw` instruction with 1 SOL
    const tx = await program.methods
      .withdraw(new anchor.BN(1 * LAMPORTS_PER_SOL)) // Withdraw 1 SOL
      .accountsPartial({
        user: provider.wallet.publicKey,            // Signer
        vaultState,
        vault,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .rpc(); // Send transaction

    // Log the transaction and show raw vault data (still exists)
    console.log("\nYour transaction signature", tx);
    console.log("Your vault balance", 
      (await provider.connection.getAccountInfo(vault)).toString()
    );
  });

  // Final test: Close the vault and vault state
  it("Close the vault", async () => {
    // Calls the `close` instruction to close both accounts and reclaim lamports
    const tx = await program.methods
      .close()
      .accountsPartial({
        user: provider.wallet.publicKey,            // Signer
        vaultState,
        vault,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .rpc(); // Send transaction

    // Log the signature and verify vault is now closed (should be null)
    console.log("\nYour transaction signature", tx);
    /*console.log("Your vault balance", 
      await provider.connection.getAccountInfo(vault)
    );*/
    const closedVaultInfo = await provider.connection.getAccountInfo(vault);

    if (closedVaultInfo) {
      // If vault exists, print balance in SOL
      console.log("Your closed vault balance", closedVaultInfo.lamports / LAMPORTS_PER_SOL, "SOL");
    } else {
      console.log("Vault account not found");
    }
  });
});

